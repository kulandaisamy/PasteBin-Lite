{"version":3,"names":["_assert","require","leap","meta","util","_core","PENDING_LOCATION","Number","MAX_VALUE","getDeclError","node","Error","JSON","stringify","catchParamVisitor","Identifier","path","state","name","catchParamName","isReference","replaceWith","getSafeParam","Scope","scope","hasOwnBinding","skip","Emitter","constructor","contextId","vars","pluginPass","nextTempId","index","indexMap","listing","returns","lastReferenceIndex","marked","insertedLocs","finalLoc","tryEntries","leapManager","Map","Set","loc","LeapManager","l","t","numericLiteral","add","getInsertedLocs","getContextId","cloneNode","getIndex","has","length","set","mark","value","assert","strictEqual","emit","isExpression","expressionStatement","assertStatement","push","emitAssign","lhs","rhs","assign","assignmentExpression","contextProperty","computed","memberExpression","stringLiteral","identifier","clearPendingException","tryLoc","assignee","catchCall","callExpression","jump","toLoc","newHelpersAvailable","breakStatement","jumpIf","test","ifStatement","blockStatement","jumpIfNot","negatedTest","isUnaryExpression","operator","argument","unaryExpression","makeContextTempVar","makeTempVar","id","generateUidIdentifier","variableDeclarator","getContextFunction","functionExpression","getDispatchLoop","self","cases","current","alreadyEnded","forEach","stmt","i","switchCase","get","isCompletionStatement","returnStatement","whileStatement","switchStatement","getTryLocsList","lastLocValue","arrayExpression","map","tryEntry","thisLocValue","firstLoc","ok","ce","catchEntry","fe","finallyEntry","locs","afterLoc","elements","reverse","explode","ignoreResult","isDeclaration","isStatement","explodeStatement","explodeExpression","type","labelId","before","after","head","isBlockStatement","containsLeap","withEntry","LabeledEntry","label","LoopEntry","first","update","init","keyIterNextFn","helper","addHelper","runtimeProperty","keyInfoTmpVar","left","emitAbruptCompletion","target","getBreakLoc","getContinueLoc","disc","defaultLoc","condition","caseLocs","c","conditionalExpression","binaryExpression","discriminant","SwitchEntry","casePath","key","elseLoc","alternate","handler","catchLoc","CatchEntry","param","finallyLoc","finalizer","FinallyEntry","TryEntry","getUnmarkedCurrentLoc","updateContextPrevLoc","body","block","bodyPath","safeParam","traverse","throwStatement","explodeClass","record","abruptArgs","explodeViaTempVar","tempVar","childPath","hasLeapingChildren","ignoreChildResult","result","isLiteral","expr","finish","onlyChildren","property","calleePath","argsPath","newCallee","newArgs","lastLeapingArgIndex","injectFirstArg","isMemberExpression","newObject","newProperty","sequenceExpression","argPath","unshift","arg","arguments","newExpression","objectExpression","propPath","isObjectProperty","objectProperty","elemPath","isSpreadElement","spreadElement","lastIndex","expressions","exprPath","prefix","temp","updateExpression","delegate","ret","explodingChildren","superClass","member","some","child","isLast","exports"],"sources":["../../src/regenerator/emit.ts"],"sourcesContent":["/* eslint-disable no-case-declarations */\nimport assert from \"node:assert\";\nimport * as leap from \"./leap.ts\";\nimport * as meta from \"./meta.ts\";\nimport * as util from \"./util.ts\";\n\nimport type { NodePath, PluginPass, Visitor, Scope } from \"@babel/core\";\nimport { types as t } from \"@babel/core\";\n\n// From packages/babel-helpers/src/helpers/regenerator.ts\nconst enum OperatorType {\n  Return = 2,\n  Jump,\n}\n\ntype AbruptCompletion =\n  | {\n      type: OperatorType.Jump;\n      target: t.NumericLiteral;\n    }\n  | {\n      type: OperatorType.Return;\n      value: t.Expression | null;\n    };\n\n// Offsets into this.listing that could be used as targets for branches or\n// jumps are represented as numeric Literal nodes. This representation has\n// the amazingly convenient benefit of allowing the exact value of the\n// location to be determined at any time, even after generating code that\n// refers to the location.\n// We use 'Number.MAX_VALUE' to mark uninitialized location. We can safely do\n// so because no code can realistically have about 1.8e+308 locations before\n// hitting memory limit of the machine it's running on. For comparison, the\n// estimated number of atoms in the observable universe is around 1e+80.\nconst PENDING_LOCATION = Number.MAX_VALUE;\n\nfunction getDeclError(node: t.Node) {\n  return new Error(\n    \"all declarations should have been transformed into \" +\n      \"assignments before the Exploder began its work: \" +\n      JSON.stringify(node),\n  );\n}\n\nconst catchParamVisitor: Visitor<{\n  getSafeParam: () => t.Identifier;\n  catchParamName: string;\n}> = {\n  Identifier: function (path, state) {\n    if (path.node.name === state.catchParamName && util.isReference(path)) {\n      path.replaceWith(state.getSafeParam());\n    }\n  },\n\n  Scope: function (path, state) {\n    if (path.scope.hasOwnBinding(state.catchParamName)) {\n      // Don't descend into nested scopes that shadow the catch\n      // parameter with their own declarations.\n      path.skip();\n    }\n  },\n};\n\nexport class Emitter {\n  nextTempId: number;\n  contextId: t.Identifier;\n  index: number;\n  indexMap: Map<number, number>;\n  listing: t.Statement[];\n  returns: Set<number>;\n  lastReferenceIndex: number = 0;\n  marked: boolean[];\n  insertedLocs: Set<t.NumericLiteral>;\n  finalLoc: t.NumericLiteral;\n  tryEntries: leap.TryEntry[];\n  leapManager: leap.LeapManager;\n  scope: Scope;\n  vars: t.VariableDeclarator[];\n\n  pluginPass: PluginPass;\n\n  constructor(\n    contextId: t.Identifier,\n    scope: Scope,\n    vars: t.VariableDeclarator[],\n    pluginPass: PluginPass,\n  ) {\n    this.pluginPass = pluginPass;\n    this.scope = scope;\n    this.vars = vars;\n\n    // Used to generate unique temporary names.\n    this.nextTempId = 0;\n\n    // In order to make sure the context object does not collide with\n    // anything in the local scope, we might have to rename it, so we\n    // refer to it symbolically instead of just assuming that it will be\n    // called \"context\".\n    this.contextId = contextId;\n\n    // An append-only list of Statements that grows each time this.emit is\n    // called.\n    this.listing = [];\n\n    this.index = 0;\n    this.indexMap = new Map([[0, 0]]);\n    this.returns = new Set();\n    this.lastReferenceIndex = 0;\n\n    // A sparse array whose keys correspond to locations in this.listing\n    // that have been marked as branch/jump targets.\n    this.marked = [true];\n\n    this.insertedLocs = new Set();\n\n    // The last location will be marked when this.getDispatchLoop is\n    // called.\n    this.finalLoc = this.loc();\n\n    // A list of all leap.TryEntry statements emitted.\n    this.tryEntries = [];\n\n    // Each time we evaluate the body of a loop, we tell this.leapManager\n    // to enter a nested loop context that determines the meaning of break\n    // and continue statements therein.\n    this.leapManager = new leap.LeapManager(this);\n  }\n\n  loc() {\n    const l = t.numericLiteral(PENDING_LOCATION);\n    this.insertedLocs.add(l);\n    return l;\n  }\n\n  getInsertedLocs() {\n    return this.insertedLocs;\n  }\n\n  getContextId() {\n    return t.cloneNode(this.contextId);\n  }\n\n  getIndex() {\n    if (!this.indexMap.has(this.listing.length)) {\n      this.indexMap.set(this.listing.length, ++this.index);\n    }\n    return this.index;\n  }\n\n  // Sets the exact value of the given location to the offset of the next\n  // Statement emitted.\n  mark(loc: t.NumericLiteral) {\n    if (loc.value === PENDING_LOCATION) {\n      loc.value = this.getIndex();\n    } else {\n      // Locations can be marked redundantly, but their values cannot change\n      // once set the first time.\n      assert.strictEqual(loc.value, this.index);\n    }\n    this.marked[this.listing.length] = true;\n    if (loc.value > this.lastReferenceIndex) {\n      this.lastReferenceIndex = loc.value;\n    }\n    return loc;\n  }\n\n  emit(node: t.Node) {\n    if (t.isExpression(node)) {\n      node = t.expressionStatement(node);\n    }\n    t.assertStatement(node);\n    this.listing.push(node);\n  }\n\n  // Shorthand for emitting assignment statements. This will come in handy\n  // for assignments to temporary variables.\n  emitAssign<T extends t.AssignmentExpression[\"left\"]>(\n    lhs: T,\n    rhs: t.Expression,\n  ) {\n    this.emit(this.assign(lhs, rhs));\n    return lhs;\n  }\n\n  // Shorthand for an assignment statement.\n  assign(lhs: t.AssignmentExpression[\"left\"], rhs: t.Expression) {\n    return t.expressionStatement(\n      t.assignmentExpression(\"=\", t.cloneNode(lhs), rhs),\n    );\n  }\n\n  // Convenience function for generating expressions like context.next,\n  // context.sent, and context.rval.\n  contextProperty(name: string) {\n    const computed = name === \"catch\";\n    return t.memberExpression(\n      this.getContextId(),\n      computed ? t.stringLiteral(name) : t.identifier(name),\n      !!computed,\n    );\n  }\n\n  clearPendingException(\n    tryLoc: t.NumericLiteral,\n    assignee: t.AssignmentExpression[\"left\"],\n  ) {\n    const catchCall = t.callExpression(this.contextProperty(\"catch\"), [\n      t.cloneNode(tryLoc),\n    ]);\n\n    if (assignee) {\n      this.emitAssign(assignee, catchCall);\n    } else {\n      this.emit(catchCall);\n    }\n  }\n\n  // Emits code for an unconditional jump to the given location, even if the\n  // exact value of the location is not yet known.\n  jump(toLoc: t.Expression) {\n    this.emitAssign(\n      this.contextProperty(\n        process.env.BABEL_8_BREAKING ||\n          util.newHelpersAvailable(this.pluginPass)\n          ? \"n\"\n          : \"next\",\n      ),\n      toLoc,\n    );\n    this.emit(t.breakStatement());\n  }\n\n  // Conditional jump.\n  jumpIf(test: t.Expression, toLoc: t.NumericLiteral) {\n    this.emit(\n      t.ifStatement(\n        test,\n        t.blockStatement([\n          this.assign(\n            this.contextProperty(\n              process.env.BABEL_8_BREAKING ||\n                util.newHelpersAvailable(this.pluginPass)\n                ? \"n\"\n                : \"next\",\n            ),\n            toLoc,\n          ),\n          t.breakStatement(),\n        ]),\n      ),\n    );\n  }\n\n  // Conditional jump, with the condition negated.\n  jumpIfNot(test: t.Expression, toLoc: t.NumericLiteral) {\n    let negatedTest;\n    if (t.isUnaryExpression(test) && test.operator === \"!\") {\n      // Avoid double negation.\n      negatedTest = test.argument;\n    } else {\n      negatedTest = t.unaryExpression(\"!\", test);\n    }\n\n    this.emit(\n      t.ifStatement(\n        negatedTest,\n        t.blockStatement([\n          this.assign(\n            this.contextProperty(\n              process.env.BABEL_8_BREAKING ||\n                util.newHelpersAvailable(this.pluginPass)\n                ? \"n\"\n                : \"next\",\n            ),\n            toLoc,\n          ),\n          t.breakStatement(),\n        ]),\n      ),\n    );\n  }\n\n  // Returns a unique MemberExpression that can be used to store and\n  // retrieve temporary values. Since the object of the member expression is\n  // the context object, which is presumed to coexist peacefully with all\n  // other local variables, and since we just increment `nextTempId`\n  // monotonically, uniqueness is assured.\n  makeContextTempVar() {\n    return this.contextProperty(\"t\" + this.nextTempId++);\n  }\n\n  makeTempVar() {\n    const id = this.scope.generateUidIdentifier(\"t\");\n    this.vars.push(t.variableDeclarator(id));\n    return t.cloneNode(id);\n  }\n\n  getContextFunction() {\n    return t.func